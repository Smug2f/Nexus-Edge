package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.events.ChorusEvent;
import com.gamesense.api.event.events.PacketEvent;
import com.gamesense.api.event.events.RenderEvent;
import com.gamesense.api.setting.values.ColorSetting;
import com.gamesense.api.setting.values.IntegerSetting;
import com.gamesense.api.util.render.GSColor;
import com.gamesense.api.util.render.RenderUtil;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;

import java.util.ArrayList;

@Module.Declaration(name = "ChorusPost", category = Category.Exploits)
public class ChorusPost extends Module {

    boolean startCancel = false;
    ArrayList<Packet<?>> packets = new ArrayList<>();
    ColorSetting colorChorus = registerColor("Color Chorus", new GSColor(255, 255, 255));
    IntegerSetting alpha = registerInteger("Alpha", 50, 0, 255);

    boolean isSendingPackets = false;
    @Override
    public void onUpdate() {
        if (mc.world == null || mc.player == null)
            packets.clear();

        else if (mc.gameSettings.keyBindSneak.isPressed()) {
            isSendingPackets = true;
            for(int i = 0; i < packets.size(); i++)
                mc.player.connection.sendPacket(packets.get(i));
            isSendingPackets = false;
            packets.clear();
            startCancel = false;
        }
    }

    @Override
    protected void onEnable() {
        startCancel = isSendingPackets = false;
    }

    int x, y, z;

    @EventHandler
    private final Listener<ChorusEvent> onUpdateWalkingPlayerEventListener = new Listener<>(event -> {
        startCancel = true;
        x = (int) mc.player.posX;
        y = (int) mc.player.posY;
        z = (int) mc.player.posZ;
    });

    @EventHandler
    private final Listener<PacketEvent.Send> packetSendListener = new Listener<>(event -> {
        if (mc.world == null || mc.player == null || !startCancel || isSendingPackets)
            return;

        Packet<?> pack = event.getPacket();



        if (pack instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook pl = (SPacketPlayerPosLook) pack;
            if (x != (int) pl.x || y != pl.y || z != pl.z)
                mc.player.setPosition(pl.x, pl.y, pl.z);
            event.cancel();
        } else
        if (event.getPacket() instanceof CPacketPlayer) {
            this.packets.add(pack);
            event.cancel();
        } else
        if (event.getPacket() instanceof CPacketConfirmTeleport) {
            this.packets.add(pack);
            event.cancel();
        }
    });

    public void onWorldRender(RenderEvent event) {
        if (startCancel)
            RenderUtil.drawBoundingBox(
                    mc.player.getEntityBoundingBox(),
                    2f,
                    new GSColor(colorChorus.getColor().getRed(), colorChorus.getColor().getGreen(), colorChorus.getColor().getBlue(), alpha.getValue())
            );
    }


}