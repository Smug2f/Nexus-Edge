package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.Phase;
import com.gamesense.api.event.events.DamageBlockEvent;
import com.gamesense.api.event.events.OnUpdateWalkingPlayerEvent;
import com.gamesense.api.event.events.RenderEvent;
import com.gamesense.api.setting.values.*;
import com.gamesense.api.util.player.InventoryUtil;
import com.gamesense.api.util.player.PlayerPacket;
import com.gamesense.api.util.player.RotationUtil;
import com.gamesense.api.util.render.GSColor;
import com.gamesense.api.util.render.RenderUtil;
import com.gamesense.api.util.world.BlockUtil;
import com.gamesense.api.util.world.GeometryMasks;
import com.gamesense.client.manager.managers.PlayerPacketManager;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import com.gamesense.client.module.modules.combat.CevBreaker;
import com.gamesense.client.module.modules.combat.PistonCrystal;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.init.MobEffects;
import net.minecraft.item.Item;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec2f;
import net.minecraft.util.math.Vec3d;

import java.util.Arrays;

/*
    @author: TechAle and Hossier
    last edit 06/04/21
 */

/**
 * Thanks to:
 * A special thank to Kami147 for making this exploit public
 * https://github.com/Kami147/InstantMine/blob/main/InstantMine.java
 */

@Module.Declaration(name = "FastBreak", category = Category.Exploits, priority = 250)
public class FastBreak extends Module {

    ModeSetting mode = registerMode("Mode", Arrays.asList("Packet", "Damage", "Instant", "Breaker"), "Packet");

    BooleanSetting continueBreaking = registerBoolean("Continue Breaking", true);
    BooleanSetting disableContinueShift = registerBoolean("Disable Continue Shift", true, () -> continueBreaking.getValue());
    BooleanSetting continueBreakingAlways = registerBoolean("Always Continue", false, () -> continueBreaking.getValue());

    DoubleSetting startDamage = registerDouble("Start Damage", 0.1, 0, 1, () -> mode.getValue().equals("Damage"));
    DoubleSetting endDamage = registerDouble("End Damage", 0.9, 0, 1, () -> mode.getValue().equals("Damage"));
    BooleanSetting haste = registerBoolean("Haste", false, () -> mode.getValue().equals("Damage"));

    BooleanSetting switchPick = registerBoolean("Switch Pick", false, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    BooleanSetting switchBack = registerBoolean("Switch Back", false, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    BooleanSetting silentSwitch = registerBoolean("Silent Switch", false, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    BooleanSetting stopEating = registerBoolean("Stop Eating", false, () -> (mode.getValue().equals("Breaker") || mode.getValue().equals("Packet")) && silentSwitch.getValue());
    BooleanSetting spammer = registerBoolean("Spammer", false, () -> mode.getValue().equals("Breaker"));
    BooleanSetting ignoreChecks = registerBoolean("Ignore Checks", false, () -> mode.getValue().equals("Breaker"));
    BooleanSetting onlyOnPick = registerBoolean("Only On Pick", false, () -> mode.getValue().equals("Breaker"));
    BooleanSetting startPick = registerBoolean("Start Pick", false, () -> mode.getValue().equals("Breaker"));
    IntegerSetting resetTickDestroy = registerInteger("Tick Reset Destroy", 0, 0, 50, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    IntegerSetting pickTickSwitch = registerInteger("Pick Switch Destroy", 75, 0, 200, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    IntegerSetting pickStill = registerInteger("Pick Switch Still", 20, 0, 30, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    BooleanSetting showProgress = registerBoolean("Show Progress", false, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    ColorSetting progressColor = registerColor("Progress Color", new GSColor(255, 255, 255), () -> (mode.getValue().equals("Breaker") || mode.getValue().equals("Packet")) && showProgress.getValue());
    BooleanSetting sus = registerBoolean("Non-Linear Render",false,() -> showProgress.getValue() && showProgress.isVisible());
    IntegerSetting spammerTickDelay = registerInteger("Spammer Delay", 0, 0, 75, () -> mode.getValue().equals("Breaker"));
    IntegerSetting breakerTickDelay = registerInteger("Breaker Delay", 0, 0, 75, () -> mode.getValue().equals("Breaker"));
    BooleanSetting forceRotation = registerBoolean("Force Rotation", false, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    IntegerSetting rangeDisableBreaker = registerInteger("Range Disable Breaker", 15, 6, 50, () -> mode.getValue().equals("Breaker"));
    BooleanSetting display = registerBoolean("Display", false, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));
    ColorSetting blockColor = registerColor("Block Color", new GSColor(255, 0, 0), () -> (mode.getValue().equals("Breaker") || mode.getValue().equals("Packet")) && display.getValue());
    ColorSetting doneColor = registerColor("Done Color", new GSColor(0, 255, 0), () -> (mode.getValue().equals("Breaker") || mode.getValue().equals("Packet")) && display.getValue());
    ModeSetting renderMode = registerMode("Render", Arrays.asList("Outline", "Fill", "Both"), "Both", () -> (mode.getValue().equals("Breaker") || mode.getValue().equals("Packet")) && display.getValue());
    IntegerSetting width = registerInteger("Width", 1, 1, 10, () -> (mode.getValue().equals("Breaker") || mode.getValue().equals("Packet")) && display.getValue());
    BooleanSetting debugChat = registerBoolean("Debug Chat", false, () -> mode.getValue().equals("Breaker") || mode.getValue().equals("Packet"));

    private int tick = 99;
    private int tickSpammer = 0;
    private int oldslot;
    private int breakTick = 0;
    private int wait = 100;


    private BlockPos lastBlock = null;
    private BlockPos continueBlock = null;
    private boolean pickStillBol = false,
                    ready = false;
    private EnumFacing direction;
    private boolean minedBefore = false;
    private int reseTick;

    private Vec3d lastHitVec = null;
    @EventHandler
    private final Listener<OnUpdateWalkingPlayerEvent> onUpdateWalkingPlayerEventListener = new Listener<>(event -> {
        if (event.getPhase() != Phase.PRE || lastHitVec == null || !forceRotation.getValue() || lastBlock == null)
            return;
        Vec2f rotation = RotationUtil.getRotationTo(lastHitVec);
        PlayerPacket packet = new PlayerPacket(this, rotation);
        PlayerPacketManager.INSTANCE.addPacket(packet);
    });

    boolean broke = false;

    public void onUpdate() {

        if (continueBreaking.getValue()) {
            if (continueBlock != null) {
                if (disableContinueShift.getValue() && mc.gameSettings.keyBindSneak.isKeyDown())
                    continueBlock = null;
                else {
                    if (BlockUtil.getBlock(continueBlock) instanceof BlockAir) {
                        broke = true;
                    }
                    if (!(BlockUtil.getBlock(continueBlock) instanceof BlockAir) && (broke || continueBreakingAlways.getValue())) {
                        mc.player.swingArm(EnumHand.MAIN_HAND);
                        mc.playerController.onPlayerDamageBlock(continueBlock, EnumFacing.UP);
                        broke = false;
                    }
                }
            }
        }

        /*
            So, this is a little bit complex.
            I want to use the same things for every switch we will ever encounter, both with switch or switchback or switch still
            So, tick = 99 is when we have done
         */
        if (tick != 99) {
            // Simple timer
            if (tick++ >= wait) {
                // Save slot in case of switch back
                int prev = mc.player.inventory.currentItem;
                ready = true;
                // If oldslot != -1 (who know, i dont wanna random crashes)
                if (switchPick.getValue() && oldslot != -1) {
                    // Change
                    if (silentSwitch.getValue()) {
                        mc.player.connection.sendPacket(new CPacketHeldItemChange(oldslot));
                        mc.playerController.updateController();
                        if (lastBlock != null && direction != null)
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, lastBlock, direction));
                        if (stopEating.getValue() && mc.player.isHandActive())
                            mc.player.stopActiveHand();
                    }
                    else
                        mc.player.inventory.currentItem = oldslot;
                    oldslot = -1;
                }
                // If we have to change
                if (!pickStillBol) {
                    // So, in case we have to switch back
                    if (pickTickSwitch.getValue() != 0 && switchPick.getValue()) {
                        // New wait
                        wait = pickStill.getValue();
                        // Reset tick
                        tick = 0;
                        // New oldslot
                        oldslot = prev;
                        // do not enter this if again basically
                        pickStillBol = true;
                    } else {
                        // Else, just finish
                        tick = 99;
                        if (silentSwitch.getValue()) {
                            mc.player.connection.sendPacket(new CPacketHeldItemChange(prev));
                            mc.playerController.updateController();
                        }
                        else {
                            mc.player.inventory.currentItem = prev;
                        }
                    }
                    // Just finish in case we have not to switch
                } else
                    tick = 99;
            }
        }

        // This is for making breaker working
        mc.playerController.blockHitDelay = 0;

        if (haste.getValue()) {
            PotionEffect effect = new PotionEffect(MobEffects.HASTE, 80950, 1, false, false);
            mc.player.addPotionEffect(new PotionEffect(effect));
        }
        if (!(haste.getValue()) && mc.player.isPotionActive(MobEffects.HASTE)) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }
        /*
            So, we have a lot of options and i tried to keep everything united.
            The first if, enter only if: Or we have a pick on the mainhand, or we have choose that we can do everything even without pick
         */
        if (!onlyOnPick.getValue() || mc.player.getHeldItemMainhand().getItem() instanceof ItemPickaxe)
            // The second check for breaker, if cevBreaker allow us to use breaker
            if ((mode.getValue().equals("Breaker") && !CevBreaker.isPossible) || CevBreaker.forceBrk) {
                // The second, first check if we have a lastblock, if yes, it's just a timer
                if (lastBlock != null && ((spammer.getValue() && tickSpammer++ >= spammerTickDelay.getValue()))) {
                    // Reset timer
                    tickSpammer = 0;
                    // If it's air, reset
                    if (BlockUtil.getBlock(lastBlock) instanceof BlockAir) {
                        minedBefore = true;
                        reseTick = 0;
                        lastHitVec = null;
                    }
                    // If we have mined it before
                    if (minedBefore) {
                        if (resetTickDestroy.getValue() != 0 && reseTick++ >= resetTickDestroy.getValue() && !(BlockUtil.getBlock(lastBlock) instanceof BlockAir)) {
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, lastBlock, direction));
                            breakerBreak();
                            reseTick = 0;
                            minedBefore = false;
                            if (debugChat.getValue())
                                PistonCrystal.printDebug("Reset Block", false);
                            return;
                        }
                        // Here, we check if it's air in case we have choose to not spam it every time
                        if (ignoreChecks.getValue() || !(BlockUtil.getBlock(lastBlock) instanceof BlockAir)) {
                            if (forceRotation.getValue())
                                setVec3d(lastBlock, direction);
                            // Get distance, if it's >=, then delete it
                            if (mc.player.getDistanceSq(lastBlock) >= rangeDisableBreaker.getValue())
                                lastBlock = null;
                            else {
                                // Finally break it
                                breakerBreak();
                            }
                        }
                    }
                }
            }
    }

    // Actual function for breaker, this is used by both update and event
    private void breakerBreak() {
        // Get item
        Item item = mc.player.inventory.getCurrentItem().getItem();
        // OldSlot
        int oldSlot = -1;
        // Switch to pick
        if (!(item instanceof ItemPickaxe) && minedBefore && (switchBack.getValue() || switchPick.getValue())) {
            oldSlot = mc.player.inventory.currentItem;
            int slot = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
            // Who know? Do you want to get kicked?
            if (slot != -1)
                mc.player.inventory.currentItem = slot;
        }
        // Send STOP_DESTROY_BLOCK
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
            lastBlock, direction));
        // If oldSlot != -1, so we have switchback
        if (oldSlot != -1 && switchBack.getValue()) {
            // Allow to switchback
            tick = 0;
            oldslot = oldSlot;
            // Since we use it for both packet and breaker, we have to do these checks
            if (!minedBefore || (mode.getValue().equals("Packet") && !CevBreaker.forceBrk)) {
                wait = pickTickSwitch.getValue();
                pickStillBol = !switchBack.getValue();
            } else
                wait = pickStill.getValue();
        }

    }

    // Listener of damageblockevent
    @EventHandler
    private final Listener<DamageBlockEvent> listener = new Listener<>(event -> {

        if (mc.world == null || mc.player == null) return;
        if (!canBreak(event.getBlockPos()) || event.getBlockPos() == null) return;

        if (CevBreaker.forceBrk) {
            breakerAlgo(event);
            return;
        }

        if (forceRotation.getValue())
            setVec3d(event.getBlockPos(), event.getEnumFacing());

        if (continueBreaking.getValue())
            continueBlock = event.getBlockPos();

        switch (mode.getValue()) {
            case "Packet": {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                event.cancel();
                lastBlock = event.getBlockPos();
                direction = event.getEnumFacing();
                oldslot = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
                tick = 0;
                wait = pickTickSwitch.getValue();
                ready = false;
                pickStillBol = false;
                break;
            }
            case "Damage": {
                if (mc.playerController.curBlockDamageMP < startDamage.getValue())
                    mc.playerController.curBlockDamageMP = startDamage.getValue().floatValue();

                if (mc.playerController.curBlockDamageMP >= endDamage.getValue()) {
                    mc.playerController.curBlockDamageMP = 1.0f;
                }
                break;
            }
            case "Instant": {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.playerController.onPlayerDestroyBlock(event.getBlockPos());
                mc.world.setBlockToAir(event.getBlockPos());
                break;
            }
            case "Breaker": {
                breakerAlgo(event);
                break;
            }
        }
    });

    private void setVec3d(BlockPos pos, EnumFacing side) {
        BlockPos neighbour = pos.offset(side);
        EnumFacing opposite = side.getOpposite();
        lastHitVec = new Vec3d(neighbour).add(0.5, 0.5, 0.5).add(new Vec3d(opposite.getDirectionVec()).scale(0.5));
    }

    // Algo for breaker when first launched, this is heavely modified from ciru's instabreaker
    private void breakerAlgo(DamageBlockEvent event) {
        // Checks if we have already entered here
        if (lastBlock == null || event.getBlockPos().x != lastBlock.x || event.getBlockPos().y != lastBlock.y || event.getBlockPos().z != lastBlock.z) {
            if (startPick.getValue()) {
                int pick = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
                if (pick != -1)
                    mc.player.inventory.currentItem = pick;
            }
            // Start breaking normally
            minedBefore = false;
            mc.player.swingArm(EnumHand.MAIN_HAND);
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
            lastBlock = event.getBlockPos();
            direction = event.getEnumFacing();
        }
        // This is a simple timer in case we want to limit the packets during cevbreaker
        if (breakerTickDelay.getValue() <= breakTick++) {
            // Algo Breaker
            breakerBreak();
            event.cancel();
            breakTick = 0;
        }
        wait = pickTickSwitch.getValue();
        ready = false;
        tick = 0;
        // Switch to pick, dont run if cevbreaker
        if (!CevBreaker.isActive && switchPick.getValue()) {
            oldslot = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
            pickStillBol = !switchBack.getValue();
        }
    }

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public void onDisable() {
        if (haste.getValue()) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }
        breakTick = 0;
        continueBlock = null;
    }

    public void onWorldRender(RenderEvent event) {
        if (lastBlock != null)
            if (mc.player.getDistanceSq(lastBlock) >= rangeDisableBreaker.getValue()) {
                lastBlock = null;
            } else if (display.getValue()) {
                if (mode.getValue().equals("Breaker") || CevBreaker.forceBrk || (mode.getValue().equals("Packet") && !(BlockUtil.getBlock(lastBlock) instanceof BlockAir)) || (mode.getValue().equals("Packer")))
                    renderBox(lastBlock);
                else lastBlock = null;
            }
    }

    // Render box
    private void renderBox(BlockPos blockPos) {
        GSColor color = ready ? doneColor.getValue() : blockColor.getValue();

        float prognum = ((((float) tick / pickTickSwitch.getValue() * 100)
                / Blocks.OBSIDIAN.blockHardness) * mc.world.getBlockState(blockPos).getBlock().blockHardness);
        // i have no idea what techale was doing but it works for obsidian so ima just make it work for whatever block

        if (showProgress.getValue()) {
            String[] progress = ready ? new String[]{"100%"}
                : new String[]{String.format("%.02f%%", prognum)};
            RenderUtil.drawNametag((double) blockPos.getX() + 0.5d, (double) blockPos.getY() + 0.5d,
                    (double) blockPos.getZ() + 0.5d, progress, progressColor.getColor(), 1);
        }

        renderESP(new AxisAlignedBB(blockPos), prognum, color);
        // from BreakESP
    }

    private void renderESP(AxisAlignedBB axisAlignedBB, double progress, GSColor color) {
        GSColor fillColor = new GSColor(color, 50);
        GSColor outlineColor = new GSColor(color, 255);

        if (sus.getValue())
            progress = Math.pow(progress / 10,2);

        if (color == doneColor.getColor()) {

            progress = 100;

        }

        double centerX = axisAlignedBB.minX + ((axisAlignedBB.maxX - axisAlignedBB.minX) / 2);
        double centerY = axisAlignedBB.minY + ((axisAlignedBB.maxY - axisAlignedBB.minY) / 2);
        double centerZ = axisAlignedBB.minZ + ((axisAlignedBB.maxZ - axisAlignedBB.minZ) / 2);
        double progressValX = progress * ((axisAlignedBB.maxX - centerX) / 100);
        double progressValY = progress * ((axisAlignedBB.maxY - centerY) / 100);
        double progressValZ = progress * ((axisAlignedBB.maxZ - centerZ) / 100);

        AxisAlignedBB axisAlignedBB1 = new AxisAlignedBB(centerX - progressValX, centerY - progressValY, centerZ - progressValZ, centerX + progressValX, centerY + progressValY, centerZ + progressValZ);

        switch (renderMode.getValue()) {
            case "Fill": {
                RenderUtil.drawBox(axisAlignedBB1, true, 0, fillColor, GeometryMasks.Quad.ALL);
                break;
            }
            case "Outline": {
                RenderUtil.drawBoundingBox(axisAlignedBB1, width.getValue(), outlineColor);
                break;
            }
            default: {
                RenderUtil.drawBox(axisAlignedBB1, true, 0, fillColor, GeometryMasks.Quad.ALL);
                RenderUtil.drawBoundingBox(axisAlignedBB1, width.getValue(), outlineColor);
                break;
            }
        }
    }

}